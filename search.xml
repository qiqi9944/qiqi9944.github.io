<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>8259</title>
    <url>/2020/05/12/8259/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CSMA/CD协议</title>
    <url>/2020/05/14/csma-cd%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="适配器的重要功能："><a href="#适配器的重要功能：" class="headerlink" title="适配器的重要功能："></a>适配器的重要功能：</h2><ul>
<li>进行串行/并行转换。</li>
<li>对数据进行缓存。</li>
<li>在计算机的操作系统安装设备驱动程序。</li>
<li>实现以太网协议。<br><strong>网络接口板又称为通信适配器或网络接口卡 NIC 或“网卡”。</strong></li>
</ul>
<p>最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p>
<pre><code>总线上的每一个工作的计算机都能检测到 B 发送的数据信号。 
由于只有计算机 D 的地址与数据帧首部写入的地址一致，因此只有 D 才接收这个数据帧。 
其他所有的计算机（A, C 和 E）都检测到不是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来。
具有广播特性的总线上实现了一对一的通信。</code></pre><p> <img src="/2020/05/14/csma-cd%E5%8D%8F%E8%AE%AE/1.png" alt> </p>
<h2 id="以太网采取的两种重要的措施："><a href="#以太网采取的两种重要的措施：" class="headerlink" title="以太网采取的两种重要的措施："></a>以太网采取的两种重要的措施：</h2><ul>
<li>采用较为灵活的无连接的工作方式，即不必先建立连接就可以直接发送数据。 </li>
<li>以太网对发送的数据帧不进行编号，也不要求对方发回确认。<pre><code>- 这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。 </code></pre></li>
</ul>
<h2 id="以太网发送的数据都使用曼彻斯特-Manchester-编码"><a href="#以太网发送的数据都使用曼彻斯特-Manchester-编码" class="headerlink" title="以太网发送的数据都使用曼彻斯特(Manchester)编码"></a>以太网发送的数据都使用曼彻斯特(Manchester)编码</h2><p><img src="/2020/05/14/csma-cd%E5%8D%8F%E8%AE%AE/2.png" alt></p>
<h2 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h2><ul>
<li>“多点接入”表示许多计算机以多点接入的方式连接在一根总线上。</li>
<li>“载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 <ul>
<li>总线上并没有什么“载波”。因此“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。  </li>
</ul>
</li>
<li>“碰撞检测”就是计算机边发送数据边检测信道上的信号电压大小。<pre><code>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。
当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。
所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。
每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。
当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 
A 向 B 发出的信息，要经过一定的时间后才能传送到 B。
B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞。
碰撞的结果是两个帧都变得无用。  </code></pre><img src="/2020/05/14/csma-cd%E5%8D%8F%E8%AE%AE/3.png" alt></li>
</ul>
<hr>
<h2 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h2><ul>
<li>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</li>
<li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li>
<li>这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。<pre><code>最先发送数据帧的站，在发送数据帧后至多经过时间（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。
以太网的端到端往返时延（两倍的端到端往返时延）称为争用期，或碰撞窗口。
经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</code></pre><pre><code>以太网取 51.2us 为争用期的长度。
对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节,所以以太网最短的帧长为64字节。
以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。
以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</code></pre><h2 id="二进制指数类型退避算法"><a href="#二进制指数类型退避算法" class="headerlink" title="二进制指数类型退避算法"></a>二进制指数类型退避算法</h2>发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。<ul>
<li>基本退避时间取为争用期（两倍的端到端往返时延）。</li>
<li>从整数集合[0,1,…, (2k 1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。</li>
<li>参数 k 按下面的公式计算：<pre><code>k = Min[重传次数, 10]</code></pre></li>
<li>当 k&lt;=10 时，参数 k 等于重传次数。</li>
<li>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。 </li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>局域网</title>
    <url>/2020/05/14/c%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<h2 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h2><p><strong>局域网最主要的特点是</strong>：<br>     网络为一个单位所拥有，且地理范围和站点数目均有限。（不含有网络层，因为它不需要路由器）<br><strong>局域网具有如下的一些主要优点：</strong><br>     - 具有广播功能，从一个站点可很方便地访问全网。<strong>局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</strong><br>     - 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。<br>     - 提高了系统的可靠性、可用性和残存性。<br>     - 将 802.3 局域网简称为“以太网”。<br><em>“以太网”应当是指符合 DIX Ethernet V2 标准的局域网</em> </p>
<hr>
<h2 id="局域网的拓扑"><a href="#局域网的拓扑" class="headerlink" title="局域网的拓扑"></a>局域网的拓扑</h2><p><img src="/2020/05/14/c%E5%B9%BF%E6%92%AD/pu.png" alt> <img src="/2020/05/14/c%E5%B9%BF%E6%92%AD/tuo.png" alt><br>我们物理上使用的星型拓扑，但是逻辑上仍然使用总线型。</p>
<hr>
<h2 id="数据链路层的两个子层"><a href="#数据链路层的两个子层" class="headerlink" title="数据链路层的两个子层"></a>数据链路层的两个子层</h2><p>为了使数据链路层能更好地适应多种局域网标准，将局域网的数据链路层拆成两个子层：</p>
<ul>
<li>逻辑链路控制 LLC (Logical Link Control)子层</li>
<li>媒体接入控制 MAC (Medium Access Control)子层。<pre><code>与接入到传输媒体有关的内容都放在 MAC子层,而 LLC 子层则与传输媒体无关
不管采用何种协议的局域网对 LLC 子层来说都是透明的</code></pre></li>
</ul>
<hr>
<h2 id="适配器的重要功能："><a href="#适配器的重要功能：" class="headerlink" title="适配器的重要功能："></a>适配器的重要功能：</h2><ul>
<li>进行串行/并行转换。</li>
<li>对数据进行缓存。</li>
<li>在计算机的操作系统安装设备驱动程序。</li>
<li>实现以太网协议。  </li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>ppp协议</title>
    <url>/2020/05/14/ppp%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="点对点协议PPP-现在全世界使用得最多的数据链路层协议是点对点协议-PPP"><a href="#点对点协议PPP-现在全世界使用得最多的数据链路层协议是点对点协议-PPP" class="headerlink" title="点对点协议PPP:现在全世界使用得最多的数据链路层协议是点对点协议 PPP"></a>点对点协议PPP:现在全世界使用得最多的数据链路层协议是点对点协议 PPP</h2><p>   PPP 协议有三个组成部分 </p>
<ul>
<li><p>一个将 IP 数据报封装到串行链路的方法。</p>
</li>
<li><p>链路控制协议 LCP (Link Control Protocol)。</p>
</li>
<li><p>网络控制协议 NCP (Network Control </p>
<pre><code>标志字段 F = 0x7E （符号“0x”表示后面的字符是用十六进制表示。十六进制的 7E 的二进制表示是 01111110）。
地址字段 A 只置为 0xFF。地址字段实际上并不起作用。
控制字段 C 通常置为 0x03。
PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。

PPP 有一个 2 个字节的协议字段。
当协议字段为 0x0021 时，PPP 帧的信息字段就是IP 数据报。
若为 0xC021, 则信息字段是 PPP 链路控制数据。
若为 0x8021，则表示这是网络控制数据。       </code></pre></li>
</ul>
<p>   <strong>帧格式</strong><br>   <img src="/2020/05/14/ppp%E5%8D%8F%E8%AE%AE/ppp.png" alt><br>   <strong>透明传输问题</strong></p>
<ul>
<li><p>当 PPP 用在同步传输链路时，协议规定采用硬件来完成比特填充。</p>
<pre><code>PPP 协议用在 SONET/SDH 链路时，是使用同步传输（一连串的比特连续传送）。这时 PPP 协议采用零比特填充方法来实现透明传输。
在发送端，只要发现有 5 个连续 1，则立即填入一个 0。
接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除。</code></pre></li>
<li><p>当 PPP 用在异步传输时，就使用一种特殊的字符填充法。</p>
<pre><code>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。 
若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。
若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。  
</code></pre></li>
</ul>
<hr>
<h2 id="不提供使用序号和确认的可靠传输"><a href="#不提供使用序号和确认的可靠传输" class="headerlink" title="不提供使用序号和确认的可靠传输"></a>不提供使用序号和确认的可靠传输</h2><ul>
<li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li>
<li>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>
<li>帧检验序列 FCS 字段可保证无差错接受。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>七层协议</title>
    <url>/2020/05/12/%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h2><hr>
<ul>
<li>应用层<br>应用层：最靠近用户的一层，为用户提供接口和各种网络服务，HTTP HTTPS FTP POP3 SMTP等<br>Eg:A的老板想要发送一个财务分析报表，这个报表就是应用层提供的一种网络服务。</li>
<li>表示层<br>表示层：对应用层数据进行编码和转换，保证一系统的应用层发送的数据能够被另一个系统的应用层所识别。必要时可以其进行加密，压缩等。<br>Eg:例如AB两个公司用英语进行通信，表示层的作用就是传递的信息转换成英语，同时为了防止其他公司看到，会进行加密处理。</li>
<li>会话层<br>会话层：建立，管理终止，表示层之间的通信会话。<br>Eg：会话层接收到表示层发过来数据时，他会根据器信息建立并记录本次会话，他首先找到B公司的地址信息，然后将所有信息放在一个信封中，加上地址和电话号，将他寄出，等到B公司收到后会终止本次会话。</li>
<li>传输层<br>传输层：建立了主机端到端的链接，他的作用就是为上层提供端到端的服务。<br>Eg:就是公司中负责快递收发的人，公司自己的投递员，负责将上一层要传递的资料传递给邮局或公司。</li>
<li>网络层<br>网络层：通过ip寻址建立两点之间的链接，为远端运输层送来的数据进行分组，选择合适的路由和交换节点，正确无误的将地址传送个目的端的运输层。这一层就是ip层，也就是internet的基础。<br>Eg：网络层相当于快递公司的庞大快递网络，通过一些集散中心到达目的地，这里的集散器就是ip节点。</li>
<li>数据链路层<br>数据链路层：将比特组合成字节，将字节再组合成帧，使用链路层地址（以太网的mac地址）来访问介质，进行差错检测。<br>逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</li>
<li>网络层<br>网络层：实现最终的信号传输，通过物理介质传送比特流。常用的设备有集线器，中继器，调制解调器，网线，双绞线，同轴电缆。<br>Eg交通工具相当于物理层，eg火车，飞机，汽车等。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>函数调用时用到的寄存器</title>
    <url>/2020/05/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="函数调用所要进行的操作"><a href="#函数调用所要进行的操作" class="headerlink" title="函数调用所要进行的操作"></a>函数调用所要进行的操作</h2><hr>
<ul>
<li>EBP<br>EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</li>
<li>ESP<br>ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。</span><br><span class="line">下一步，foo必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。</span><br><span class="line">sub esp, 0cch；减去的值根据程序而定</span><br><span class="line">之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）</span><br><span class="line">之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了</span><br><span class="line">在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作</span><br></pre></td></tr></table></figure></li>
<li>EBX<br>EBX：”基地址”(base)寄存器, 在内存寻址时存放基地址。</li>
<li>ESI<br>ESI/EDI分别叫做”源/目标索引寄存器”(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串.</li>
</ul>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/TuxedoLinux/article/details/100921994" target="_blank" rel="noopener">https://blog.csdn.net/TuxedoLinux/article/details/100921994</a></p>
<p><a href="https://blog.csdn.net/zhu2695/article/details/16813425" target="_blank" rel="noopener">https://blog.csdn.net/zhu2695/article/details/16813425</a></p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2020/05/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h2 id="数据链路层的两种类型"><a href="#数据链路层的两种类型" class="headerlink" title="数据链路层的两种类型"></a>数据链路层的两种类型</h2><p>   <strong>数据链路层传送的是帧</strong></p>
<ul>
<li>点对点通信：这种信道使用一对一的点对点通信方式。<pre><code>链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。
一条链路只是一条通路的一个组成部分。
数据链路(data link)除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。
现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。
一般的适配器都包括了数据链路层和物理层这两层的功能。   </code></pre></li>
<li>广播信道：这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送 </li>
</ul>
<hr>
<h2 id="数据链路层的简单模型"><a href="#数据链路层的简单模型" class="headerlink" title="数据链路层的简单模型"></a>数据链路层的简单模型</h2><h2 id><a href="#" class="headerlink" title="   "></a>   <img src="/2020/05/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/wang.png" alt></h2><h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><ul>
<li><p>封装成帧<br>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。<br>首部和尾部的一个重要作用就是进行帧定界<br><img src="/2020/05/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/zhen.png" alt></p>
</li>
<li><p>透明传输<br><img src="/2020/05/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/tou.png" alt><br>解决透明传输的问题</p>
<pre><code>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)。
字节填充(byte stuffing)或字符填充(character stuffing)
——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。
如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。
——当接收端收到连续的两个转义字符时，就删除其中前面的一个。</code></pre><p><img src="/2020/05/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/fufu.png" alt> </p>
</li>
<li><p>差错控制<br>在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。<br>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。<br>误码率与信噪比有很大的关系。<br>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 </p>
<h2 id="在数据链路层传送的帧中，广泛使用了循环冗余检验-CRC-的检错技术。"><a href="#在数据链路层传送的帧中，广泛使用了循环冗余检验-CRC-的检错技术。" class="headerlink" title="在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。"></a>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。</h2><pre><code>在发送端，先把数据划分为组。
假定每组 k 个比特。 
假设待传送的一组数据 M = 101001（现在 k = 6）。
我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送。  

用二进制的模 2 运算进行 2n 乘 M 的运算，这相当于在 M 后面添加 n 个 0。
得到的 (k + n) 位的数除以事先选定好的长度为 (n + 1) 位的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少1 位，即 R 是 n 位。 
</code></pre><p><img src="/2020/05/14/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/crc.png" alt> </p>
<h2 id="帧检验序列-FCS"><a href="#帧检验序列-FCS" class="headerlink" title="帧检验序列 FCS"></a>帧检验序列 FCS</h2><pre><code>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。
循环冗余检验 CRC 和帧检验序列 FCS并不等同。
CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。
FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。  

(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受(accept)。
(2) 若余数 R  0，则判定这个帧有差错，就丢弃。
- 但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。
- 只要经过严格的挑选，并使用位数足够多的除数 P，那么出现检测不到的差错的概率就很小很小。 </code></pre></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2020/05/14/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h2 id="物理层的传输媒体"><a href="#物理层的传输媒体" class="headerlink" title="物理层的传输媒体"></a>物理层的传输媒体</h2><hr>
<pre><code> - 双绞线
   屏蔽双绞线和无屏蔽双绞线。
- 同轴电缆

- 光缆
   在纤芯中不断的全反射 
   分为多模光纤和单模光纤
</code></pre><hr>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ul>
<li>频分复用<br>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。<br>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）</li>
<li>时分复用<br>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。<br>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM  帧的长度）<br>TDM 信号也称为等时(isochronous)信号<br>时分复用的所有用户是在不同的时间占用同样的频带宽度。<br> <img src="/2020/05/14/%E7%89%A9%E7%90%86%E5%B1%82/hexo.png" alt><br> 但是有可能造成线路资源的浪费<br> <img src="/2020/05/14/%E7%89%A9%E7%90%86%E5%B1%82/shi.png" alt></li>
<li>统计时分复用<br> 解决了时分复用的问题<br> <img src="/2020/05/14/%E7%89%A9%E7%90%86%E5%B1%82/cao.png" alt></li>
<li>码分复用 CDM<br> 常用的名词是码分多址 CDMA<br> 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br> 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。<br> 每一个比特时间划分为 m 个短的间隔，称为码片(chip)。<pre><code>每个站被指派一个唯一的 m bit 码片序列。
如发送比特 1，则发送自己的 m bit 码片序列。
如发送比特 0，则发送该码片序列的二进制反码。 
例如，S 站的 8 bit 码片序列是 00011011。
发送比特 1 时，就发送序列 00011011，
发送比特 0 时，就发送序列 11100100。
S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)</code></pre></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>停止等待协议和连续arq协议</title>
    <url>/2020/05/14/%E8%BF%9E%E7%BB%ADarq%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h2 id="停止等待协议的工作特点："><a href="#停止等待协议的工作特点：" class="headerlink" title="停止等待协议的工作特点："></a>停止等待协议的工作特点：</h2><p>   单工的工作方式<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在同一时间内只能发送一个数据帧</span><br><span class="line">没有错误发送ACK，有错误发送NAK</span><br><span class="line">在收到确认帧是发送方发送下一个帧，收到否认帧时重新发送，所以说用一个编号就可以控制</span><br><span class="line">它会设置一个计时器，这个数值的大小要大于往返时延</span><br></pre></td></tr></table></figure><br>   算法描述<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发方程序：</span><br><span class="line">(1)   从主机取一个数据帧，送交发送缓存。</span><br><span class="line">(2)   V(S)←0。 </span><br><span class="line">(3)   N(S)←V(S)。</span><br><span class="line">(4)   将发送缓存中的数据帧发送出去。 </span><br><span class="line">(5)   设置超时计时器。</span><br><span class="line">(6)   等待。 </span><br><span class="line">(7)   收到确认帧 ACKn，   </span><br><span class="line">        若 n &#x3D; 1 – V(s)，则：</span><br><span class="line">           从主机取一个新的数据帧，放入发送缓存；</span><br><span class="line">           V(S)←[1 – V(S)]，转到 (3)。    </span><br><span class="line">        否则，丢弃这个确认帧，转到(6)。 </span><br><span class="line">(8)   若超时计时器时间到，则转到(4)。</span><br><span class="line">收方程序：</span><br><span class="line">(1)   V(R)←0。</span><br><span class="line">(2)   等待。</span><br><span class="line">(3)   收到一个数据帧；</span><br><span class="line">        若 CRC校验无误</span><br><span class="line">          若 N(S) &#x3D; V(R)，则执行(4)；</span><br><span class="line">          否则丢弃此数据帧，然后转到(6)。</span><br><span class="line">        否则丢弃此数据帧，然后转到(2)。</span><br><span class="line">(4)   将收到的数据帧中的数据部分送交上层软件</span><br><span class="line">(5)   V(R)←[1 – V(R)]。</span><br><span class="line">(6)   n←V(R)；</span><br><span class="line">      发送确认帧 ACKn，转到(2)。</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="arq工作特点："><a href="#arq工作特点：" class="headerlink" title="arq工作特点："></a>arq工作特点：</h2><p>   全双工的工作方式<br>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以连续发送多个数据帧</span><br><span class="line">ackn:标识对前面的n-1号帧进行确认，并且希望收到n号帧</span><br><span class="line">因为是按序接受的，不按序正确也不要，所以</span><br><span class="line">如果发送方发送三个数据帧，接收方只接受到第三个确认帧，那么它也可以确定前两个数据帧已经接收成功，可以发送下一帧</span><br><span class="line">它也会设置一个计时器，这个数值的大小要大于往返时延</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h2><p>   通常由接收方对发送方进行流量控制，发送方自己也会控制</p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><ul>
<li>发送方 WT：<br>只能发送WT大小的值，并且有计时机制，如果在这个时间内没有收到则会重传窗口内的值，只有接收到窗口内的确认信号才可以滑动窗口</li>
<li>接收方 WR：<br>只能接受窗口的大小的帧，收到后会移动窗口并且发送确认帧<br>WT&lt;=2的n次幂-1<br>WR&lt;=2的n-1次幂<br>WT+WR&lt;=2的n次幂</li>
</ul>
]]></content>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
